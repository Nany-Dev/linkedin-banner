<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lauane Moraes - Creative Developer</title>
  <style>
    body {
      margin: 0;
      /* Fundo */
      background-color: #ffffff;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      cursor: none; /* Esconde o cursor padrão para usar a bolinha */
    }
    #container {
      width: 100%;
      height: 100vh;
      /* Centraliza o texto */
      display: flex;
      justify-content: center;
      align-items: center;
      /* Garante que o texto fique na frente do efeito */
      position: relative;
      z-index: 2; 
    }
    .texto-menu {
      /* Estilo do seu nome */
      font-size: 10vw; /* Tamanho responsivo */
      font-weight: 900; 
      color: #000000; /* Cor preta */
      text-transform: uppercase;
      letter-spacing: -5px;
      /* Importante: A cor precisa ser a mesma da bolinha para o efeito "grudar" */
      mix-blend-mode: difference; 
      color: #fff; /* Cor branca para o mix-blend-mode funcionar com o fundo preto do efeito */
    }
    canvas {
        /* WebGL */
        display: block;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 1; 
        pointer-events: none; 
    }
  </style>
</head>
<body>

<div id="container">
  <h1 class="texto-menu">LAUANE</h1>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>

<script>

    const container = document.body;
    let width = container.offsetWidth;
    let height = container.offsetHeight;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    camera.position.z = 10; // Aproxima ou afasta a câmera

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // A "Bolinha" 
    const geometry = new THREE.PlaneBufferGeometry(20, 20, 32, 32);
    
    // Os Shaders 
    const material = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uMouse: { value: new THREE.Vector2(0, 0) },
        uResolution: { value: new THREE.Vector2(width, height) },
        uStrength: { value: 0 }, // Força do efeito ao mover
        uHover: { value: 0 }     // Força extra ao passar no texto
      },
      // Vertex Shader
      vertexShader: `
        uniform float uTime;
        uniform vec2 uMouse;
        uniform vec2 uResolution;
        uniform float uStrength;
        varying vec2 vUv;
        void main() {
          vUv = uv;
          vec3 pos = position;
          // Converte a posição do mouse para o espaço 3D
          vec2 center = vUv * 2.0 - 1.0;
          center.x *= uResolution.x / uResolution.y;
          vec2 mouse = uMouse * 2.0 - 1.0;
          mouse.x *= uResolution.x / uResolution.y;
          
          // Calcula a distância e aplica a distorção "líquida"
          float dist = distance(center, mouse);
        
          float strength = smoothstep(0.5, 0.0, dist) * uStrength;
          pos.z += strength * 2.0; // Puxa a malha para frente
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      // Fragment Shader: Controla a cor e a transparência (a bolinha preta)
      fragmentShader: `
        uniform float uTime;
        uniform vec2 uMouse;
        uniform vec2 uResolution;
        varying vec2 vUv;
        void main() {
          vec2 center = vUv * 2.0 - 1.0;
          center.x *= uResolution.x / uResolution.y;
          vec2 mouse = uMouse * 2.0 - 1.0;
          mouse.x *= uResolution.x / uResolution.y;
          float dist = distance(center, mouse);
          
          // Cria o círculo preto suave
          float alpha = smoothstep(0.15, 0.0, dist);
          gl_FragColor = vec4(0.0, 0.0, 0.0, alpha); // Cor preta (0,0,0)
        }
      `,
      transparent: true
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // --- Interação com o Mouse ---
    let mouse = new THREE.Vector2(0, 0);
    let targetMouse = new THREE.Vector2(0, 0);

    window.addEventListener('mousemove', (e) => {
      // Normaliza a posição do mouse de 0 a 1
      targetMouse.x = e.clientX / width;
      targetMouse.y = 1 - e.clientY / height; // Inverte o Y para WebGL

      // Aumenta a "força" do efeito quando o mouse se move rápido
      gsap.to(material.uniforms.uStrength, {
        value: 2.0, // Quão forte ele distorce ao mover
        duration: 0.1,
        ease: 'power2.out',
        onComplete: () => {
           // Volta a força ao normal quando para de mover
           gsap.to(material.uniforms.uStrength, { value: 0, duration: 0.5 });
        }
      });
    });

    // Detecta quando o mouse passa sobre o texto
    const textElement = document.querySelector('.texto-menu');
    textElement.addEventListener('mouseenter', () => {
      // Aumenta o efeito de "grudar" e a bolinha
      gsap.to(material.uniforms.uHover, { value: 1, duration: 0.3 });
      // Aumenta o tamanho da bolinha ao passar no texto
      gsap.to(mesh.scale, { x: 1.5, y: 1.5, duration: 0.3 });
    });
    textElement.addEventListener('mouseleave', () => {
      // Volta ao normal
      gsap.to(material.uniforms.uHover, { value: 0, duration: 0.3 });
      gsap.to(mesh.scale, { x: 1.0, y: 1.0, duration: 0.3 });
    });


    // --- Loop de Animação ---
    function animate() {
      // Suaviza o movimento da bolinha (lerp)
      mouse.x += (targetMouse.x - mouse.x) * 0.1;
      mouse.y += (targetMouse.y - mouse.y) * 0.1;
      
      material.uniforms.uMouse.value = mouse;
      material.uniforms.uTime.value += 0.01;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // --- Responsividade (Redimensionar a tela) ---
    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      material.uniforms.uResolution.value.set(width, height);
    });
</script>
</body>
</html>